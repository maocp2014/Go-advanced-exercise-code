package main

import "fmt"

// 闭包，引用了形参，值传递（传递的指针值）
func foo1(x *int) func() {
	return func() {
		*x = *x + 1  // 会修改原x的值
		fmt.Printf("foo1 val = %d\n", *x)
	}
}

// 闭包，值传递
func foo2(x int) func() {
	return func() {
		x = x + 1
		fmt.Printf("foo2 val = %d\n", x)
	}
}

func main() {
	// Q1第一组实验  这是因为闭包f1\f2都保存了x=133时的整个环境
	x := 133
	f1 := foo1(&x)
	f2 := foo2(x)
	f1() // 134
	f2() // 134
	f1() // 135
	f2() // 135

	// Q1第二组
	// 有趣的事情发生了！f1的值居然发生了显著性的变化！通过这组实验，能够更好地解释其（函数）
	// 相关的引用环境其实就是产生这个闭包的时候的外部函数的环境，因此变量x的可见性和作用域也
	// 与外部函数相同，又因为foo1是“引用传递”，变量x的作用域不局限在foo1()中，
	// 因此当x发生变化的时候，闭包f1内部也变化了。这个也正好是"反之，那么闭包其实不再封闭，
	// 全局可见的变量的修改，也会对闭包内的这个变量造成影响"的证明。
	x = 233
	f1()  // 234
	f2()  // 136
	f1()  // 235
	f2()  // 137

	// Q1第三组
	// 因为foo1()返回的闭包都会修改变量x的数值，因此调用foo1()()之后，变量x必然增加1。
	// 而foo2()返回的闭包仅仅修改其内部环境的变量x而对调用外部的变量x不影响，且每次调用foo2()返回的
	// 闭包是独立的，和其他调用foo2()的闭包不相关，因此最后两次的调用，打印的数值都是相同的；
	// 第一次调用和第二次调用foo2()发现打印出来的数值增加了1，是因为两次调用之间传入的x的数值分别
	// 是236和237，而不是说第二次在第一次基础上增加了1，这点需要补充说明。
	foo1(&x)() // 236
	foo2(x)()  // 237
	foo1(&x)()  // 237
	foo2(x)()  // 238
	foo2(x)()  // 238
}